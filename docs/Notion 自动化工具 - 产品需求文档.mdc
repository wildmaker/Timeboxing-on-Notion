---
description: 
globs: 
alwaysApply: false
---

## 1. 需求概述
### 1. 1 需求背景
我在实践 Elon Musk 的 Time Boxing 工作法，这个工作法的核心是将工作任务分解拆分为 5 分钟左右的时间盒（Time Box），然后一天就按照拆分好的时间盒序列进行工作，超过 Time Box 的 DDL 任务如果没有完成，就切换到下一个时间盒。
为了实践这个方法，我是用 Notion + Notion Calendar 作为我的日程管理工具。我使用 Notion 的某一个 Database 作为我的日程管理数据库，我所有的日程都记录在这个 Database 里。
我的日程管理工作流是：
1. 列出所有今日任务，并列出优先级；
2. 对任务进行拆分，将任务拆分为 TimeBox，并且标记优先级；
3. 估算每个子任务的时长；
4. 安排休息任务；
5. 根据子任务求和计算父任务的总时长；
6. 将所有任务分配到一天中的可用时间段中，进行排程；
### 1. 2 关键痛点
我的关键痛点在于每天的日程排程的手动操作工作量太大，我希望将其自动化。具体的手工完成任务有：
* 根据子任务求和计算父任务的总时长；
* 每隔一段时间安排休息任务；
* 将所有任务首尾衔接，分配到一天中的可用时间段；
* 手动更新日程：某个日程中途变更时，手动更新后续的所有日程

## 2. 功能清单
我希望实现这些功能，以便于自动化日程排程的工作。
### 2.1 集成配置
工具启动时，用户需要通过配置模块提交必要的数据，系统进行初始化。后期也能通过该模块管理配置。

- **连接 Notion:** 允许用户提供 Notion API token 来连接他们的工作区
- **配置日程数据库**：用户通过指定日历数据库的 URL来告诉服务器日历数据存储的位置。完成进行时长、优先级等字段的映射；
### 2.2  自动化排程
用户可以在完成任务拆分后，指令系统进行自动化排程。系统根据日程列表自动计算任务的时间段、自动安排休息时间等，最后更新日程数据库中每个任务的起始时间字段，完成排程。
### 2.2  自动化更新日程
用户可以更新某个日程中的任务安排后，指令系统更新后续的日程安排。系统自动将后续的任务按照更新的日程进行批量延期或者提前。

## 3. 需求描述
### 2.1 集成配置
* **初始化配置引导**
	* 用户进入系统时，应该检查是否已经完成初始化配置。
	* 如果用户没有完成配置，系统应该引导用户完成配置。
* **配置项**
	* 在配置过程中，用户需要顺序完成下列配置：
		* **连接 Notion 的日程 Database:**
			* 用户需要提交 API Token 和 Notion 日程 Database 的 URL。
			* 从 URL 中解析Database的 ID；然后发送测试请求检查是否能正常连接工作区。
			* 如果可以正常连接，就把Database的 ID、API Token 记录在数据库。
	    - **映射数据库与字段:**
		    - 系统列出所有必要的字段，让用户选择Notion 中分别对应哪一个数据列，从而完成字段映射；
		    - 必要的字段：
			    - 标题
			    - 时间盒字段（同时记录了开始和结束时间）
			    - 状态
			    - 时长
			    - 优先级（P0~P5）
			    - 父任务（记录了任务的父任务列表）
			    - 子任务（记录了任务的子任务列表）
			- 状态字段的配置：
				- 在配置“状态”的字段映射时，应该展开配置哪些状态属性的值对应“待办”、“进行中”、“已完成”
				- Notion Database 中“状态”字段一个状态对应了多个值，例如“收件箱”、“已计划”都属于待办状态。
				- 排程状态：（已完成/未完成）
			
* **配置管理**
	* 系统完成初始化配置后，用户也可以在配置模块更新上述配置。
### 2.2  自动化排程
- **排程的基准点:** 在排程时，用户可以指定排程的开始时间作为排程的基准点。如果没有指定，系统默认以当前时间后15分钟作为排程基准点；
- **Notion Databas中日程任务的数据结构：**
	- 任务按照树状结构组织，一个任务可能有多个子任务，一个子任务也可能有多个子任务。
	- 一个任务的子任务和父任务分别记录在 Database中 “父任务”和“子任务”属性中
- **排程的算法：
	1. **初始化待排任务列表**：从 Databse 中筛选符合条件（开始时间是今天 && 状态属于”未开始“&& 父任务为空 && 排程状态=“未完成”）的任务数据，初始化待排任务列表：
	2. 初始化排程层级 level = 0
	3. **递归排程**：按照下述算法，递归排程：
		1. 从**待排任务列表**中找到未排程的任务中优先级最高的任务
			1. 如果找到了，就将这个任务作为**待排任务** 
			2. 如果没有找到：
				1. 表明任务列表内的任务已经排程完成。
				2. 查找当前**待排任务列表**中第一个任务的父节点
					1. 如果找不到：说明全部任务已经排程，退出排程；
					2. 如果找的到：
						1. 查找第一个任务的爷爷节点
							1. 如果找不到，说明父任务是一级根节点。这时候就查找父任务为空 && 排程状态=“未完成”的任务作为**待排任务列表**
							2. 如果找的到：就查找爷爷节点的子任务列表，用子任务列表作为**待排任务列表**
						2. 回到第1步；
				3. 检查排程层级 level 是否为 0：
					1. 如果是 0 ，表示
					2. 如果不是 0，表示还在对中间节点的任务进行排程，这时候需要将**待排任务列表**切换到上级任务列表，切换的流程如下：
						1. 
						2. 查找这个父任务的父任务：
							1. 如果找不到
		2. 检查这个**待排任务**是否有未完成排程（排程状态=“未完成”）的子任务，
			2-1. 如果有，就更新**待排任务列表**为子任务的列表，回到第1步；
			2-2. 如果没有，就对**待排任务**进行排程
				2-2-1. 更新任务：
					1. 将排程的基准点时间作为任务的开始时间
					2. 更新任务的结束时间：
						1. 如果任务是叶节点（没有子任务）：
							1. 结束时间 = 开始时间 + 时长
						2. 否则：结束时间 = 结束时间最晚的子任务的结束时间
					3. 更新任务的排程状态=已完成
				2-2-2. 更新排程基准点为任务的结束时间
				2-2-3. 回到第 1 步

  -  待定：安排日程时自动在连续工作45～60分钟后插入15分钟休息间隔
### 2.3 自动化更新日程
用户可以手动将某个任务的排程状态改为未完成，然后指令系统批量更新这个日程后续的日程

## 3. 用户界面
- 基于网页的界面，允许用户执行上述操作（连接、配置数据库、延迟任务）
- 在不同部分之间清晰导航（例如连接页面、数据库选择/配置页面、任务延迟页面）
- 为 API 交互提供加载指示器和错误处理

## 4. 技术实现
- 使用 Flask 框架构建后端服务
- 使用 Notion API 进行数据库操作
- 使用 SQLite 数据库存储用户配置和任务状态
- 使用 HTML/CSS/JavaScript 构建前端界面
- 使用 AJAX 实现异步交互
